//==============================================================
// Draw Functions
//==============================================================

function drawBall() {
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, Math.PI*2); // the first 2 numbers are the x/y coordinates on the screen, the 3rd is size/radius. The 4th is...fill? Maybe? x was originally 50, y was originally 50. They are replaced here as 'x' and 'y' to help make them move. See below.
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
}

function drawPaddle (){
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();

}



function draw(){
    ctx.clearRect(0, 0, canvas.width, canvas.height); /// THIS LINE OF CODE IS ESSENTIAL - IT CLEARS THE CANVAS BEFORE EACH FRAME, meaning the ball won't leave a train
    drawBall()
    drawPaddle()
    ballBrickColl()

     var bricksMatrix = manager.brickGrid;

    for (let r = 0; r < bricksMatrix.length; r++){
        for (let c = 0; c < bricksMatrix[r].length; c++) {
            var brick = bricksMatrix[r][c];
            brick.draw();
           
        }
    }





/// The above, i've gotten it to at least draw a new grid of bricks, but without collision detection.



    collisionDetection()
    drawScore()
    x += ballSpeedX;
    y += ballSpeedY;

    if (x + ballSpeedX > canvas.width-ballRadius || x + ballSpeedX < ballRadius) {
        ballSpeedX = -ballSpeedX;
    }///adding in the ballRadius means the ball doesn't "disappear" into the wall as it hits

    if (y + ballSpeedY < ballRadius) {
        ballSpeedY = -ballSpeedY;
    } else if (y + ballSpeedY > canvas.height-ballRadius || y + ballSpeedY < ballRadius) {
        if (x > paddleX && x < paddleX + paddleWidth) {
            ballSpeedY = -ballSpeedY; ///this else-if is for collission detection with the paddle.
        }
        else {alert("GAME OVER");
        document.location.reload();
        clearInterval(interval);
    }
    }  

    if(rightPressed){
        paddleX += 7;
        //the next lines keep the paddle on the screen
        if (paddleX + paddleWidth > canvas.width){
            paddleX = canvas.width - paddleWidth;
        }
    }
    else if(leftPressed){
        paddleX -=7;
        //the next lines keep the paddle on the screen
        if (paddleX < 0) {  ///why is this 0? Basically, because of x/y coordinates. an x of 0 means you are all the way to the left as it is.
            paddleX = 0;
        }
    }
    
    if (brickCount == -36) {
        new gameManager(12,3);
        
    }
   
}


//==============================================================
// Player Controls
//==============================================================

var rightPressed = false;
var leftPressed = false; // False to start, because false = not pressed, and no one starts off the game with something moving.

document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false); //These two event listenrs are only looking for if ANY key is pressed down or ANY key is released. You can use these to create functions for specific keys now, and what they do. See below.

function keyDownHandler(e) { // 'e' is simply an event as a parameter, represented as 'e' here.
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = true;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = true;
    }  /// 'Right' and 'Left are specific for IE/edge browsers, where as 'ArrowRight' etc. is for all other browsers. Putting them both in ensures universal compatibility.
}

function keyUpHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = false;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft"){
        leftPressed = false;
    }
}

//We now need to add paddle moving logic, which will be stored in the draw() function. Look above for rightPressed and leftPressed to see whats going on.


/// Ball collision detection
function collisionDetection() {

    var bricksMatrix = manager.brickGrid;

    for (let r = 0; r < bricksMatrix.length; r++){
        for (let c = 0; c < bricksMatrix[r].length; c++) {
            let b = bricksMatrix[r][c]
          
            if (b.status >= 1) {
                if (x > b.x && x < b.x+b.width && y > b.y && y < b.y+b.height){
                    ballSpeedY = -ballSpeedY;
                    b.status = b.status - 1;

                    console.log('MANAGER HERE', manager)
                  /*   console.log ("BRICK GRID", manager.rowArray) */

                    //IS ROW GONE?
                    var isRowDepleted = manager.isRowDepleted(b);


                    //LETS ADD MORE ROWS

                  
                    /*manager.brickGrid // This is the grid for the game
                    manager.isRowDepleted // Boolean

                    manager.brickGrid.unshift("VARIABLE") // The variable you want to go here. This will be how you add a new row. */


                  /*   for (let b = 0; b < bricksMatrix.length; b++){
                        if (b.status < 1) {
                            new gameManager(12, 12)
                        }
                    } */

/*                     const isTrue = manager.brickGrid.every(obj => obj.status == 0);
                    console.log ("IS TRUE TRUE TRUE", isTrue); */

/*                     const isTrue = bricksMatrix.every(obj => obj.status == 0)
                    console.log ("IS TRUE TRUE TRUE", isTrue);
                    
                    if (b.status == 0){
                        console.log ("THE STATUS IS ZEERRRRRROOOO")
                    } */

                    

/*                     let statuses = [];
                    console.log("SDKLJFHSLKDJFHLSKDJHFLKSJDHFKSJHDF", statuses)
                    for (let i = 0, j = 0; i < bricksMatrix.length, j < bricksMatrix.length; i ++, j ++) {
                        if (statuses.indexOf(bricksMatrix[i].status) === 0 && (bricksMatrix[j].status) === 0)
                        console.log("CHECHCHCEHECHCEHEHCECHECCHE", bricksMatrix[i].status)
                        statuses.push(bricksMatrix[i].status);}
                        if (statuses.length === 1){
                            console.log("THEY ARE ALL THE SAME")
                        } */
                        
                    


                    if (r == 11 &&  isRowDepleted == true){
                        console.log("THE LAST ROW HAS BEEN DESTROYED.")
                       
                         /* manager.newEverything() ; */
                        
                        
                       /*  new gameManager.rowArray.push(0) */
                        /* manager.brickGrid.unshift(0)  */

                    }
                
                    console.log("Brick hit belonged to row: " + r + " | Is row depleted? " + isRowDepleted);

                 
                    score ++;
                    brickCount --;
                    console.log("BRIRRIRIRIRIRIRIRIRIRIRIRIRIR", brickCount)

                    if (brickCount == -36) {
                        /*  numChoice ++; */
                         manager;
                         ballBrickColl();
                         
                     }



             
                     // this adds to the score function we have below
                   /*  if(score == brickRowCount * brickColumnCount) {
                        alert("YOU WIN!");
                        document.location.reload();
                        clearInterval(interval);
                    } */
                   
                }
            }
        }
    }
}
